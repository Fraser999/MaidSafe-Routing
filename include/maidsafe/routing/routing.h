/*  Copyright 2014 MaidSafe.net limited

    This MaidSafe Software is licensed to you under (1) the MaidSafe.net Commercial License,
    version 1.0 or later, or (2) The General Public License (GPL), version 3, depending on which
    licence you accepted on initial access to the Software (the "Licences").

    By contributing code to the MaidSafe Software, or to this project generally, you agree to be
    bound by the terms of the MaidSafe Contributor Agreement, version 1.0, found in the root
    directory of this project at LICENSE, COPYING and CONTRIBUTOR respectively and also
    available at: http://www.maidsafe.net/licenses

    Unless required by applicable law or agreed to in writing, the MaidSafe Software distributed
    under the GPL Licence is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS
    OF ANY KIND, either express or implied.

    See the Licences for the specific language governing permissions and limitations relating to
    use of the MaidSafe Software.                                                                 */

#ifndef MAIDSAFE_ROUTING_ROUTING_H_
#define MAIDSAFE_ROUTING_ROUTING_H_

#include "boost/asio/ip/udp.hpp"

#include "maidsafe/common/node_id.h"
#include "maidsafe/rudp/managed_connections.h"

namespace maidsafe {

namespace routing {
using EndPoint = boost::asio::ip::endpoint;
using PublicKey = asymm::PublicKey;

class Routing {
 public:
  // create a non-mutating client
  Routing();

  // Providing :
  // pmid as a paramater will create a non client routing object(vault).
  // maid as a paramater will create a mutating client.
  // Non-mutating client means that random keys will be generated by routing for this node.
  template <typename FobType>
  explicit Routing(const FobType& fob) {
    asymm::Keys keys;
    keys.private_key = fob.private_key();
    keys.public_key = fob.public_key();
    InitialisePimpl(detail::is_client<FobType>::value, NodeId(fob.name()->string()), keys);
  }

  Routing(const Routing&) = delete;
  Routing(Routing&&) = delete;
  Routing& operator=(const Routing&) = delete;
  Routing& operator=(Routing&&) = delete;

  ~Routing();
  // ##########################New API ideas###################################
  // Used for bootstrapping (joining) and can be used as zero state network if both ends
  // are started simultaneously or to join a explicit & specific node
  void BootStrap(Endpoint our_endpoint, Endpoint their_endpoint, PublicKey their_public_key);
  //  use hard coded nodes or cache file
  void BootStrap();
  // register callbacks / services
  int32_t RegisterServiceX(std::function<void>(std::string()) callback) {
    service_x.push_back(callback);  // iterate to call each callback in a range based for
  }

  void UnRegisterServiceX(int32_t) {
    std::erase(std::remove_if())  // find and erase service
  }

  void UnRegisterServiceXAll() { service_x.clear(); }

  std::vector<std::pair<int32_t, std::function<void>(std::string))>> service_x;

  //###########################end########################################


  // Sends message to a known destination. (Typed Message API).  Throws on invalid paramaters.
  template <typename T>
  void Send(const T& message);

  // Sends message to a known destnation.
  // If a valid response functor is provided, it will be called when:
  // a) the response is receieved or,
  // b) waiting time (Parameters::default_response_timeout) for receiving the response expires
  // Throws on invalid paramaters
  void SendDirect(const NodeId& destination_id,       // ID of final destination
                  const std::string& message,         // payload
                  bool cacheable,                     // whether to cache message content
                  ResponseFunctor response_functor);  // Called on response

  // Sends message to Parameters::group_size most closest nodes to destination_id. The node
  // having id equal to destination id is not considered as part of group and will not receive
  // group message
  // If a valid response functor is provided, it will be called when:
  // a) for each response receieved (Parameters::group_size responses expected) or,
  // b) waiting time (Parameters::default_response_timeout) for receiving the response expires
  // Throws on invalid paramaters
  void SendGroup(const NodeId& destination_id,       // ID of final destination or group centre
                 const std::string& message,         // payload
                 bool cacheable,                     // whether to cache message content
                 ResponseFunctor response_functor);  // Called on each response

  // Compares own closeness to target against other known nodes' closeness to the target
  bool ClosestToId(const NodeId& target_id);

  // Gets a random connected node from routing table (excluding closest
  // Parameters::closest_nodes_size nodes).
  // Shouldn't be called when routing table is likely to be smaller than closest_nodes_size.
  NodeId RandomConnectedNode();

  // Evaluates whether the sender_id is a legitimate source to send a request for performing
  // an operation on info_id
  bool EstimateInGroup(const NodeId& sender_id, const NodeId& info_id) const;

  // Returns this node's id.
  const NodeId OurId() const;

  // Returns a number between 0 to 100 representing % network health w.r.t. number of connections
  int network_status();


  // Checks if routing table contains given node id
  bool IsConnectedVault(const NodeId& node_id);

  // Checks if client routing table contains given node id
  bool IsConnectedClient(const NodeId& node_id);
};

}  // namespace routing

}  // namespace maidsafe

#endif  // MAIDSAFE_ROUTING_ROUTING_H_
